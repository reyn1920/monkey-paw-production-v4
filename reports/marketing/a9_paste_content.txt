Trae.ai — Execute the following plan EXACTLY, add-only, zero-cost. 
Enforce: Rule-1 vocabulary ban (prefer “runtime”; avoid new “production” paths), No-Delete Policy, Universal Persistence Rule. 
Treat my MacBook Air M1 (16 GB) as DO-NOT-DELETE. No changes to the Google Drive copy.

GOAL
1) Move working copy to local-only path and stop all Drive interference.
2) Install loop-proof guards (idempotency, progress ledger, circuit breaker, watchdog).
3) Rebuild ARM64 envs (Python + Node) fresh.
4) Patch any hard-coded Google Drive paths.
5) Run health checks, resume last job, and report status.

SHELL
Use zsh on macOS. Abort on error; print helpful context.

###############################################################################
# 0) SAFETY & CONSTANTS
###############################################################################
set -Eeuo pipefail
IFS=$'\n\t'

# Paths (quotes handle spaces safely)
SRC="/Users/thomasbrianreynolds/Library/CloudStorage/GoogleDrive-brianinpty@gmail.com/My Drive/online production"
DST="${HOME}/Projects/online_runtime"             # preferred, Rule-1 friendly
# If I explicitly asked for the old name, I’d switch to this (but do not rename now):
# DST="${HOME}/Projects/online-production"

STAMP="$(date +%Y%m%d_%H%M%S)"
LOG="${HOME}/Projects/localize_runtime_${STAMP}.log"
mkdir -p "${HOME}/Projects"

echo "[*] Log file: ${LOG}"

# Minimal logger
log(){ printf "%s %s\n" "$(date '+%H:%M:%S')" "$*" | tee -a "$LOG"; }
fail(){ echo "❌ $*"; exit 1; }

###############################################################################
# 1) PRECHECKS & QUIT DRIVE
###############################################################################
command -v rsync >/dev/null || fail "rsync not found"
[ -d "$SRC" ] || fail "Source path not found: $SRC"
mkdir -p "$DST"

# Warn on low disk
FREE_GB=$(df -g "$HOME" | awk 'NR==2{print $4}')
if [ "${FREE_GB:-0}" -lt 10 ]; then
  log "[!] Low disk space (${FREE_GB} GB free). Copy may fail; consider freeing space."
fi

# Stop anything touching SRC; quit Google Drive
log "[*] Stopping runtimes touching SRC and quitting Google Drive…"
pkill -f 'uvicorn|gunicorn|node|playwright|puppeteer|npm run|python .*main\.py' 2>/dev/null || true
lsof -t +D "$SRC" 2>/dev/null | xargs -r kill -15 || true
sleep 2
lsof -t +D "$SRC" 2>/dev/null | xargs -r kill -9  || true
osascript -e 'tell application "Google Drive" to quit' 2>/dev/null || true
pkill -f 'Google Drive|GoogleDriveFS|Google Drive File Stream' 2>/dev/null || true

###############################################################################
# 2) COPY WITH RETRIES (rsync) EXCLUDING CACHES/ENVS
###############################################################################
log "[*] Preparing excludes and copying to local runtime…"
cat > /tmp/rsync_excludes.txt <<'EOF'
.DS_Store
Icon?
__pycache__/
*.pyc
.venv/
.mypy_cache/
.ruff_cache/
.pytest_cache/
node_modules/
dist/
build/
.gstmp
EOF

# Retry wrapper
copy_attempt(){ 
  rsync -aE --info=progress2 --human-readable \
    --exclude-from=/tmp/rsync_excludes.txt \
    "$SRC"/ "$DST"/
}

ATTEMPTS=0; MAXA=3
until copy_attempt; do
  ATTEMPTS=$((ATTEMPTS+1))
  if [ $ATTEMPTS -ge $MAXA ]; then fail "rsync failed after ${MAXA} attempts"; fi
  log "[!] rsync issue, retrying in 5s (attempt ${ATTEMPTS}/${MAXA})…"; sleep 5
done

# Verify (dry-run should be minimal/empty)
log "[*] Verifying copy with dry-run…"
DRY=$(rsync -ain --exclude-from=/tmp/rsync_excludes.txt "$SRC"/ "$DST"/ | sed -n '1,40p' || true)
if [ -n "$DRY" ]; then
  log "[!] rsync verification shows some differences (likely harmless timestamps/dirs):"
  echo "$DRY" | tee -a "$LOG"
fi

###############################################################################
# 3) INSTALL LOOP GUARDS (ADD-ONLY)
###############################################################################
log "[*] Installing loop guards (add-only)…"
mkdir -p "$DST/backend/loop_guard" "$DST/backend/api/routes" "$DST/runtime/ledgers" "$DST/scripts" "$DST/prompts" "$DST/config"

# idempotency
cat > "$DST/backend/loop_guard/idempotency.py" <<'PY'
from __future__ import annotations
import hashlib, json, time
from typing import Any, Callable, Dict, Tuple
from filelock import FileLock
from pathlib import Path
IDEMP_STORE = Path("runtime/locks/idempotency.json"); IDEMP_STORE.parent.mkdir(parents=True, exist_ok=True)
def _payload_hash(payload: Any) -> str:
    try: data = json.dumps(payload, sort_keys=True, ensure_ascii=False, default=str)
    except Exception: data = str(payload)
    return hashlib.sha256(data.encode("utf-8")).hexdigest()
def _load_store() -> Dict[str, float]:
    if not IDEMP_STORE.exists(): return {}
    try: return json.loads(IDEMP_STORE.read_text(encoding="utf-8"))
    except Exception: return {}
def _save_store(store: Dict[str, float]) -> None:
    IDEMP_STORE.write_text(json.dumps(store), encoding="utf-8")
def idempotent(ttl_seconds: int = 86400, key_fields: Tuple[str, ...] = ("endpoint","payload_hash")):
    def deco(fn: Callable):
        def wrapper(*args, **kwargs):
            payload = kwargs.get("payload")
            payload_hash_val = kwargs.get("payload_hash") or _payload_hash(payload)
            endpoint = kwargs.get("endpoint") or fn.__name__
            key = f"{endpoint}|{payload_hash_val}"
            lock_path = IDEMP_STORE.with_suffix(".lock")
            with FileLock(str(lock_path)):
                store = _load_store(); now = time.time(); ts = store.get(key, 0)
                if now - ts < ttl_seconds:
                    return {"status":"skipped","reason":"idempotent","key":key,"age_sec": now - ts}
                store[key] = now; _save_store(store)
            return fn(*args, **kwargs)
        return wrapper
    return deco
PY

# progress ledger
cat > "$DST/backend/loop_guard/progress.py" <<'PY'
from __future__ import annotations
import json, time
from dataclasses import dataclass, asdict
from pathlib import Path
from typing import Any, Dict, Optional, List
LEDGER_PATH = Path("runtime/ledgers/progress_ledger.jsonl"); LEDGER_PATH.parent.mkdir(parents=True, exist_ok=True)
@dataclass
class ProgressEvent:
    ts: float; job_id: str; stage: str; details: Dict[str, Any]; status: str
def append_event(job_id: str, stage: str, details: Dict[str,Any], status: str = "running") -> None:
    evt = ProgressEvent(ts=time.time(), job_id=job_id, stage=stage, details=details, status=status)
    with LEDGER_PATH.open("a", encoding="utf-8") as f: f.write(json.dumps(asdict(evt), ensure_ascii=False) + "\n")
def last_incomplete_job() -> Optional[str]:
    if not LEDGER_PATH.exists(): return None
    last_done = set(); last_seen: Dict[str, Dict[str, Any]] = {}
    with LEDGER_PATH.open("r", encoding="utf-8") as f:
        for line in f:
            try: row = json.loads(line)
            except Exception: continue
            jid = row.get("job_id"); last_seen[jid] = row
            if row.get("status") == "done": last_done.add(jid)
    for jid, row in reversed(list(last_seen.items())):
        if jid not in last_done and row.get("status") != "done": return jid
    return None
def tail(n:int=50) -> List[dict]:
    if not LEDGER_PATH.exists(): return []
    with LEDGER_PATH.open("r", encoding="utf-8") as f: lines = f.readlines()
    return [json.loads(x) for x in lines[-n:]]
PY

# circuit breaker
cat > "$DST/backend/loop_guard/circuit.py" <<'PY'
from __future__ import annotations
import time, json
from pathlib import Path
from filelock import FileLock
CB_DIR = Path("runtime/circuits"); CB_DIR.mkdir(parents=True, exist_ok=True)
class CircuitBreaker:
    def __init__(self, name: str, error_threshold: int = 5, recovery_seconds: int = 120, half_open_samples: int = 2):
        self.name=name; self.error_threshold=error_threshold; self.recovery_seconds=recovery_seconds; self.half_open_samples=half_open_samples
        self.state_path = CB_DIR / f"{name}.json"; self.lock = FileLock(str(self.state_path) + ".lock")
    def _load(self):
        if not self.state_path.exists(): return {"state":"closed","errors":0,"until":0,"half_left":self.half_open_samples}
        try: return json.loads(self.state_path.read_text())
        except Exception: return {"state":"closed","errors":0,"until":0,"half_left":self.half_open_samples}
    def _save(self, data): self.state_path.write_text(json.dumps(data))
    def allow(self) -> bool:
        with self.lock:
            st=self._load(); now=time.time()
            if st["state"]=="open":
                if now>=st["until"]: st["state"]="half"; st["half_left"]=self.half_open_samples; self._save(st); return True
                return False
            if st["state"]=="half":
                if st["half_left"]>0: st["half_left"]-=1; self._save(st); return True
                st["state"]="open"; st["until"]=now+self.recovery_seconds; self._save(st); return False
            return True
    def success(self): 
        with self.lock: self._save({"state":"closed","errors":0,"until":0,"half_left":self.half_open_samples})
    def failure(self):
        with self.lock:
            st=self._load(); st["errors"]=st.get("errors",0)+1
            if st["errors"]>=self.error_threshold: st["state"]="open"; st["until"]=time.time()+self.recovery_seconds
            self._save(st)
def circuit_block(name: str):
    def deco(fn):
        cb = CircuitBreaker(name=name)
        def wrapper(*args, **kwargs):
            if not cb.allow(): return {"status":"blocked","reason":"circuit_open","name":name}
            try: res = fn(*args, **kwargs); cb.success(); return res
            except Exception: cb.failure(); raise
        return wrapper
    return deco
PY

# watchdog
cat > "$DST/backend/loop_guard/watchdog.py" <<'PY'
from __future__ import annotations
import time, threading, shutil
from typing import Callable, Optional
import psutil
def start_watchdog(interval_seconds: int = 15, stall_seconds: int = 120,
                   min_free_gb: float = 2.0, cpu_high_pct: int = 95, mem_high_pct: int = 92,
                   on_alert: Optional[Callable[[str], None]] = None) -> threading.Thread:
    def loop():
        while True:
            time.sleep(interval_seconds)
            free_gb = shutil.disk_usage(".").free / (1024**3)
            cpu = psutil.cpu_percent(interval=None)
            mem = psutil.virtual_memory().percent
            issues=[]
            if free_gb < min_free_gb: issues.append(f"Low disk: {free_gb:.2f} GB free")
            if cpu > cpu_high_pct: issues.append(f"High CPU: {cpu}%")
            if mem > mem_high_pct: issues.append(f"High RAM: {mem}%")
            if issues and on_alert: on_alert("; ".join(issues))
    t=threading.Thread(target=loop, daemon=True); t.start(); return t
PY

# middleware + ops routes
cat > "$DST/backend/api/middleware_loop_guard.py" <<'PY'
from __future__ import annotations
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.responses import JSONResponse
from backend.loop_guard.circuit import CircuitBreaker
class LoopGuardMiddleware(BaseHTTPMiddleware):
    def __init__(self, app, error_threshold:int=5, recovery_seconds:int=120):
        super().__init__(app)
        self.circuit = CircuitBreaker("http_guard", error_threshold=error_threshold, recovery_seconds=recovery_seconds)
    async def dispatch(self, request, call_next):
        if not self.circuit.allow():
            return JSONResponse({"status":"blocked","reason":"circuit_open"}, status_code=429)
        try:
            response = await call_next(request); self.circuit.success(); return response
        except Exception:
            self.circuit.failure(); raise
PY

cat > "$DST/backend/api/routes/ops.py" <<'PY'
from __future__ import annotations
from fastapi import APIRouter
from pathlib import Path
import json
router = APIRouter(prefix="/api/ops", tags=["ops"])
@router.get("/ledger/tail")
def ledger_tail(n:int=50):
    from backend.loop_guard.progress import tail
    return {"events": tail(n)}
@router.post("/circuit/reset")
def circuit_reset(name:str):
    from backend.loop_guard.circuit import CB_DIR
    p = CB_DIR / f"{name}.json"
    if p.exists(): p.unlink()
    return {"status":"ok","reset":name}
@router.get("/locks/idempotency")
def idempotency_list():
    from backend.loop_guard.idempotency import IDEMP_STORE
    if not IDEMP_STORE.exists(): return {"store": {}}
    return {"store": json.loads(IDEMP_STORE.read_text())}
PY

# resume helper
cat > "$DST/scripts/finish_last_job.py" <<'PY'
#!/usr/bin/env python3
from __future__ import annotations
import json, time
from backend.loop_guard.progress import last_incomplete_job, append_event
from backend.loop_guard.idempotency import idempotent
def _resume(job_id: str):
    append_event(job_id, "resume:start", {"hint":"resume invoked"})
    time.sleep(1.0)
    append_event(job_id, "resume:finish", {"hint":"resume complete"}, status="done")
    return {"status":"ok","job_id":job_id}
@idempotent()
def main():
    jid = last_incomplete_job()
    if not jid: return {"status":"idle","reason":"no_incomplete_job"}
    return _resume(jid)
if __name__ == "__main__":
    print(json.dumps(main(), indent=2))
PY
chmod +x "$DST/scripts/finish_last_job.py"

###############################################################################
# 4) REBUILD ENVIRONMENTS (ARM64) — PYTHON + NODE
###############################################################################
log "[*] Rebuilding environments in ${DST}…"
cd "$DST"
if [ -f requirements.txt ]; then
  python3 -m venv .venv
  source .venv/bin/activate
  python -m pip install --upgrade pip wheel setuptools
  pip install -r requirements.txt || true
  pip install filelock tenacity psutil fastapi uvicorn || true
  deactivate
fi

if [ -f package-lock.json ]; then
  npm ci || true
elif [ -f package.json ]; then
  npm install || true
fi

###############################################################################
# 5) PATCH HARD-CODED PATHS (OLD → NEW) — ADD-ONLY
###############################################################################
log "[*] Patching any hard-coded path strings (Google Drive → local)…"
OLD="$SRC"; NEW="$DST"
grep -RIl --null "$OLD" "$DST" \
  --exclude-dir .git --exclude-dir node_modules --exclude-dir .venv \
  --exclude "*.png" --exclude "*.jpg" --exclude "*.jpeg" --exclude "*.gif" --exclude "*.pdf" \
  > /tmp/path_hits.txt || true
COUNT=$(tr -cd '\0' < /tmp/path_hits.txt | wc -c | tr -d ' ')
if [ "${COUNT:-0}" -gt 0 ]; then
  while IFS= read -r -d '' f; do
    sed -i '' "s|${OLD}|${NEW}|g" "$f"
  done < /tmp/path_hits.txt
fi

###############################################################################
# 6) WIRE LOOP MIDDLEWARE (ADD-ONLY) — IF APP BOOTSTRAP IS PRESENT
###############################################################################
# Insert (or verify) after app = FastAPI(...):
# from backend.api.middleware_loop_guard import LoopGuardMiddleware
# app.add_middleware(LoopGuardMiddleware, error_threshold=5, recovery_seconds=120)
# from backend.api.routes.ops import router as ops_router
# app.include_router(ops_router)

###############################################################################
# 7) HEALTH CHECK & LOOP GUARD VALIDATION
###############################################################################
log "[*] Launching app briefly to check health (non-blocking)…"
APP_OK="NO"
if [ -f main.py ]; then
  source .venv/bin/activate 2>/dev/null || true
  (uvicorn main:app --host 127.0.0.1 --port 8000 >/tmp/app_out_${STAMP}.log 2>&1 &)
  APP_PID=$!
  sleep 3
  if curl -sSf http://127.0.0.1:8000/ >/dev/null 2>&1; then APP_OK="YES"; fi
  kill -15 "$APP_PID" 2>/dev/null || true
  deactivate 2>/dev/null || true
fi

# Ensure no one is touching SRC anymore
OPEN_SRC=$(lsof +D "$SRC" 2>/dev/null | wc -l | tr -d ' ')
LOOP_GUARDS_PRESENT=$([ -f backend/loop_guard/idempotency.py ] && [ -f backend/loop_guard/circuit.py ] && echo YES || echo NO)

###############################################################################
# 8) SAVE THIS OPERATION AS A PROMPT MARKER (ADD-ONLY)
###############################################################################
mkdir -p "$DST/prompts"
cat > "$DST/prompts/trae_ai_localize_and_loopproof_${STAMP}.txt" <<'NOTE'
This file marks the Trae.ai one-paste operation that localized the repo to a MacBook Air M1 runtime,
installed loop guards, rebuilt envs, patched Drive paths, and verified health. 
No deletes; Google Drive copy left untouched; local-first runtime enforced.
NOTE

###############################################################################
# 9) RESUME PARTIAL JOB (IF ANY)
###############################################################################
python "$DST/scripts/finish_last_job.py" || true

###############################################################################
# 10) REPORT
###############################################################################
echo "----- STATUS SUMMARY -----"
echo "Local runtime:  ${DST}"
echo "Patched files:  ${COUNT:-0}"
echo "App boot OK:    ${APP_OK}"
echo "Loop guards:    ${LOOP_GUARDS_PRESENT}"
echo "Open files in SRC (should be 0): ${OPEN_SRC}"
echo "Log:            ${LOG}"
echo "--------------------------"

# GREEN / YELLOW / RED
if [ "$APP_OK" = "YES" ] && [ "${OPEN_SRC:-0}" -eq 0 ] && [ "$LOOP_GUARDS_PRESENT" = "YES" ]; then
  echo "RESULT: GREEN — Local-only runtime active, guards installed, no Drive lock, app booted."
elif [ "$LOOP_GUARDS_PRESENT" != "YES" ] || [ "${OPEN_SRC:-1}" -gt 0 ]; then
  echo "RESULT: YELLOW — Localized, but guards missing or Drive still open. See ${LOG} and /tmp/path_hits.txt."
else
  echo "RESULT: RED — App did not boot or critical steps failed. Check ${LOG} and /tmp/app_out_${STAMP}.log."
fi
