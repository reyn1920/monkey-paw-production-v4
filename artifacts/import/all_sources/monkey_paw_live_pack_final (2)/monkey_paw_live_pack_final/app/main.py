from fastapi import FastAPI, Body
from pydantic import BaseModel
from pathlib import Path
from typing import List, Dict, Any
import json, time

BASE = Path(__file__).resolve().parents[1]
ART_STAGING = BASE / "artifacts" / "staging"
ART_PUBLISHED = BASE / "artifacts" / "published"
REPORTS = BASE / "reports"
APPROVAL_FLAG = REPORTS / "approve_publish.true"

app = FastAPI(title="Monkey Paw Productions — Live Pack", version="1.0.0")

class ResearchIn(BaseModel):
    topic: str

class DraftIn(BaseModel):
    seed_id: int = 1
    content: str

@app.get("/api/health")
def health() -> Dict[str, Any]:
    return {"status": "ok", "time": time.time()}

@app.post("/api/research")
def research(payload: ResearchIn) -> Dict[str, Any]:
    # simple research stub writing a seed
    seed_path = ART_STAGING / f"seed_{int(time.time())}.json"
    seed = {"topic": payload.topic, "bullets": [f"Key insight about {payload.topic}", "Audience: general", "Tone: clear"]}
    seed_path.write_text(json.dumps(seed, indent=2))
    return {"ok": True, "seed_file": str(seed_path)}

@app.post("/api/draft")
def draft(payload: DraftIn) -> Dict[str, Any]:
    # Write a draft file based on the seed
    fname = ART_STAGING / f"draft_{int(time.time())}.txt"
    text = f"# Draft for seed {payload.seed_id}\n\n{payload.content}\n\n— generated by Monkey Paw pipeline\n"
    fname.write_text(text)
    return {"ok": True, "draft_file": str(fname)}

@app.post("/api/repurpose")
def repurpose(seed_id: int = 1) -> Dict[str, Any]:
    # Create a short form from latest draft
    drafts = sorted(ART_STAGING.glob("draft_*.txt"))
    if not drafts:
        return {"ok": False, "error": "No drafts available"}
    latest = drafts[-1]
    short = ART_STAGING / f"short_{latest.stem.split('_')[-1]}.txt"
    short.write_text(latest.read_text()[:400] + "\n\n# Short form\n")
    return {"ok": True, "short_file": str(short), "from": latest.name}

@app.post("/api/publish")
def publish() -> Dict[str, Any]:
    # Approval-gated move from staging to published
    if not APPROVAL_FLAG.exists():
        return {"ok": False, "error": "Not approved. Call /api/admin/approve_publish/true first."}
    moved = []
    for p in ART_STAGING.glob("*"):
        target = ART_PUBLISHED / p.name
        target.write_bytes(p.read_bytes())
        moved.append(target.name)
    return {"ok": True, "published": moved}

@app.get("/api/admin/approve_publish/{flag}")
def approve(flag: str) -> Dict[str, Any]:
    if flag.lower() == "true":
        APPROVAL_FLAG.write_text("approved")
        return {"ok": True, "approved": True}
    if APPROVAL_FLAG.exists():
        APPROVAL_FLAG.unlink()
    return {"ok": True, "approved": False}
